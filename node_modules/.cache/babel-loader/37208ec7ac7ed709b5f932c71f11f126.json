{"ast":null,"code":"import map from 'lodash.map';\nimport reduce from 'lodash.reduce';\nimport filter from 'lodash.filter';\nimport min from 'lodash.min';\nimport max from 'lodash.max';\nimport isNumber from 'lodash.isnumber';\nimport L from 'leaflet';\nimport { MapLayer } from 'react-leaflet';\nimport simpleheat from 'simpleheat';\nimport PropTypes from 'prop-types';\n\nfunction isInvalid(num) {\n  return !isNumber(num) && !num;\n}\n\nfunction isValid(num) {\n  return !isInvalid(num);\n}\n\nfunction isValidLatLngArray(arr) {\n  return filter(arr, isValid).length === arr.length;\n}\n\nfunction isInvalidLatLngArray(arr) {\n  return !isValidLatLngArray(arr);\n}\n\nfunction safeRemoveLayer(leafletMap, el) {\n  const {\n    overlayPane\n  } = leafletMap.getPanes();\n\n  if (overlayPane && overlayPane.contains(el)) {\n    overlayPane.removeChild(el);\n  }\n}\n\nfunction shouldIgnoreLocation(loc) {\n  return isInvalid(loc.lng) || isInvalid(loc.lat);\n}\n\nexport default class HeatmapLayer extends MapLayer {\n  createLeafletElement() {\n    return null;\n  }\n\n  componentDidMount() {\n    const canAnimate = this.props.leaflet.map.options.zoomAnimation && L.Browser.any3d;\n    const zoomClass = `leaflet-zoom-${canAnimate ? 'animated' : 'hide'}`;\n    const mapSize = this.props.leaflet.map.getSize();\n    const transformProp = L.DomUtil.testProp(['transformOrigin', 'WebkitTransformOrigin', 'msTransformOrigin']);\n    const tProp = typeof transformProp == \"string\" ? transformProp : '';\n\n    var _el = L.DomUtil.create('canvas', zoomClass);\n\n    _el.style[tProp] = '50% 50%';\n    _el.style.width = mapSize.x + 'px';\n    _el.style.height = mapSize.y + 'px';\n    const el = this._el;\n    const Heatmap = L.Layer.extend({\n      onAdd: leafletMap => leafletMap.getPanes().overlayPane.appendChild(el),\n      addTo: leafletMap => {\n        leafletMap.addLayer(this);\n        return this;\n      },\n      onRemove: leafletMap => safeRemoveLayer(leafletMap, el)\n    });\n    this.leafletElement = new Heatmap();\n    super.componentDidMount();\n    this._heatmap = simpleheat(this._el);\n    this.reset();\n\n    if (this.props.fitBoundsOnLoad) {\n      this.fitBounds();\n    }\n\n    this.attachEvents();\n    this.updateHeatmapProps(this.getHeatmapProps(this.props));\n  }\n\n  getMax(props) {\n    return props.max || 3.0;\n  }\n\n  getRadius(props) {\n    return props.radius || 30;\n  }\n\n  getMaxZoom(props) {\n    return props.maxZoom || 18;\n  }\n\n  getMinOpacity(props) {\n    return props.minOpacity || 0.01;\n  }\n\n  getBlur(props) {\n    return props.blur || 15;\n  }\n\n  getHeatmapProps(props) {\n    return {\n      minOpacity: this.getMinOpacity(props),\n      maxZoom: this.getMaxZoom(props),\n      radius: this.getRadius(props),\n      blur: this.getBlur(props),\n      max: this.getMax(props),\n      gradient: props.gradient\n    };\n  }\n\n  componentWillReceiveProps(nextProps) {\n    const currentProps = this.props;\n    const nextHeatmapProps = this.getHeatmapProps(nextProps);\n    this.updateHeatmapGradient(nextHeatmapProps.gradient);\n    const hasRadiusUpdated = nextHeatmapProps.radius !== currentProps.radius;\n    const hasBlurUpdated = nextHeatmapProps.blur !== currentProps.blur;\n\n    if (hasRadiusUpdated || hasBlurUpdated) {\n      this.updateHeatmapRadius(nextHeatmapProps.radius, nextHeatmapProps.blur);\n    }\n\n    if (nextHeatmapProps.max !== currentProps.max) {\n      this.updateHeatmapMax(nextHeatmapProps.max);\n    }\n  }\n  /**\n   * Update various heatmap properties like radius, gradient, and max\n   */\n\n\n  updateHeatmapProps(props) {\n    this.updateHeatmapRadius(props.radius, props.blur);\n    this.updateHeatmapGradient(props.gradient);\n    this.updateHeatmapMax(props.max);\n  }\n  /**\n   * Update the heatmap's radius and blur (blur is optional)\n   */\n\n\n  updateHeatmapRadius(radius, blur) {\n    if (radius) {\n      this._heatmap.radius(radius, blur);\n    }\n  }\n  /**\n   * Update the heatmap's gradient\n   */\n\n\n  updateHeatmapGradient(gradient) {\n    if (gradient) {\n      this._heatmap.gradient(gradient);\n    }\n  }\n  /**\n   * Update the heatmap's maximum\n   */\n\n\n  updateHeatmapMax(maximum) {\n    if (maximum) {\n      this._heatmap.max(maximum);\n    }\n  }\n\n  componentWillUnmount() {\n    safeRemoveLayer(this.props.leaflet.map, this._el);\n  }\n\n  fitBounds() {\n    const points = this.props.points;\n    const lngs = map(points, this.props.longitudeExtractor);\n    const lats = map(points, this.props.latitudeExtractor);\n    const ne = {\n      lng: max(lngs),\n      lat: max(lats)\n    };\n    const sw = {\n      lng: min(lngs),\n      lat: min(lats)\n    };\n\n    if (shouldIgnoreLocation(ne) || shouldIgnoreLocation(sw)) {\n      return;\n    }\n\n    this.props.leaflet.map.fitBounds(L.latLngBounds(L.latLng(sw), L.latLng(ne)));\n  }\n\n  componentDidUpdate() {\n    this.props.leaflet.map.invalidateSize();\n\n    if (this.props.fitBoundsOnUpdate) {\n      this.fitBounds();\n    }\n\n    this.reset();\n  }\n\n  shouldComponentUpdate() {\n    return true;\n  }\n\n  attachEvents() {\n    const leafletMap = this.props.leaflet.map;\n    leafletMap.on('viewreset', () => this.reset());\n    leafletMap.on('moveend', () => this.reset());\n\n    if (leafletMap.options.zoomAnimation && L.Browser.any3d) {\n      leafletMap.on('zoomanim', this._animateZoom, this);\n    }\n  }\n\n  _animateZoom(e) {\n    const scale = this.props.leaflet.map.getZoomScale(e.zoom);\n\n    const offset = this.props.leaflet.map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this.props.leaflet.map._getMapPanePos());\n\n    if (L.DomUtil.setTransform) {\n      L.DomUtil.setTransform(this._el, offset, scale);\n    } else {\n      this._el.style[L.DomUtil.TRANSFORM] = `${L.DomUtil.getTranslateString(offset)} scale(${scale})`;\n    }\n  }\n\n  reset() {\n    const topLeft = this.props.leaflet.map.containerPointToLayerPoint([0, 0]);\n    L.DomUtil.setPosition(this._el, topLeft);\n    const size = this.props.leaflet.map.getSize();\n\n    if (this._heatmap._width !== size.x) {\n      this._el.width = this._heatmap._width = size.x;\n    }\n\n    if (this._heatmap._height !== size.y) {\n      this._el.height = this._heatmap._height = size.y;\n    }\n\n    if (this._heatmap && !this._frame && !this.props.leaflet.map._animating) {\n      this._frame = L.Util.requestAnimFrame(this.redraw, this);\n    }\n\n    this.redraw();\n  }\n\n  redraw() {\n    const r = this._heatmap._r;\n    const size = this.props.leaflet.map.getSize();\n    const maxIntensity = this.props.max === undefined ? 1 : this.getMax(this.props);\n    const maxZoom = this.props.maxZoom === undefined ? this.props.leaflet.map.getMaxZoom() : this.getMaxZoom(this.props);\n    const v = 1 / Math.pow(2, Math.max(0, Math.min(maxZoom - this.props.leaflet.map.getZoom(), 12)) / 2);\n    const cellSize = r / 2;\n\n    const panePos = this.props.leaflet.map._getMapPanePos();\n\n    const offsetX = panePos.x % cellSize;\n    const offsetY = panePos.y % cellSize;\n    const getLat = this.props.latitudeExtractor;\n    const getLng = this.props.longitudeExtractor;\n    const getIntensity = this.props.intensityExtractor;\n\n    const inBounds = (p, bounds) => bounds.contains(p);\n\n    const filterUndefined = row => filter(row, c => c !== undefined);\n\n    const roundResults = results => reduce(results, (result, row) => map(filterUndefined(row), cell => [Math.round(cell[0]), Math.round(cell[1]), Math.min(cell[2], maxIntensity), cell[3]]).concat(result), []);\n\n    const accumulateInGrid = (points, leafletMap, bounds) => reduce(points, (grid, point) => {\n      const latLng = [getLat(point), getLng(point)];\n\n      if (isInvalidLatLngArray(latLng)) {\n        //skip invalid points\n        return grid;\n      }\n\n      const p = leafletMap.latLngToContainerPoint(latLng);\n\n      if (!inBounds(p, bounds)) {\n        return grid;\n      }\n\n      const x = Math.floor((p.x - offsetX) / cellSize) + 2;\n      const y = Math.floor((p.y - offsetY) / cellSize) + 2;\n      grid[y] = grid[y] || [];\n      const cell = grid[y][x];\n      const alt = getIntensity(point);\n      const k = alt * v;\n\n      if (!cell) {\n        grid[y][x] = [p.x, p.y, k, 1];\n      } else {\n        cell[0] = (cell[0] * cell[2] + p.x * k) / (cell[2] + k); // x\n\n        cell[1] = (cell[1] * cell[2] + p.y * k) / (cell[2] + k); // y\n\n        cell[2] += k; // accumulated intensity value\n\n        cell[3] += 1;\n      }\n\n      return grid;\n    }, []);\n\n    const getBounds = () => new L.Bounds(L.point([-r, -r]), size.add([r, r]));\n\n    const getDataForHeatmap = (points, leafletMap) => roundResults(accumulateInGrid(points, leafletMap, getBounds(leafletMap)));\n\n    const data = getDataForHeatmap(this.props.points, this.props.leaflet.map);\n\n    this._heatmap.clear();\n\n    this._heatmap.data(data).draw(this.getMinOpacity(this.props));\n\n    this._frame = null;\n\n    if (this.props.onStatsUpdate && this.props.points && this.props.points.length > 0) {\n      this.props.onStatsUpdate(reduce(data, (stats, point) => {\n        stats.max = point[3] > stats.max ? point[3] : stats.max;\n        stats.min = point[3] < stats.min ? point[3] : stats.min;\n        return stats;\n      }, {\n        min: Infinity,\n        max: -Infinity\n      }));\n    }\n  }\n\n  render() {\n    return null;\n  }\n\n}\nHeatmapLayer.propTypes = {\n  points: PropTypes.array.isRequired,\n  longitudeExtractor: PropTypes.func.isRequired,\n  latitudeExtractor: PropTypes.func.isRequired,\n  intensityExtractor: PropTypes.func.isRequired,\n  fitBoundsOnLoad: PropTypes.bool,\n  fitBoundsOnUpdate: PropTypes.bool,\n  onStatsUpdate: PropTypes.func,\n\n  /* props controlling heatmap generation */\n  max: PropTypes.number,\n  radius: PropTypes.number,\n  maxZoom: PropTypes.number,\n  minOpacity: PropTypes.number,\n  blur: PropTypes.number,\n  gradient: PropTypes.object\n};\n;","map":{"version":3,"sources":["/home/cuemura/Documents/tcheqme_web/src/HeatmapLayer.ts"],"names":["map","reduce","filter","min","max","isNumber","L","MapLayer","simpleheat","PropTypes","isInvalid","num","isValid","isValidLatLngArray","arr","length","isInvalidLatLngArray","safeRemoveLayer","leafletMap","el","overlayPane","getPanes","contains","removeChild","shouldIgnoreLocation","loc","lng","lat","HeatmapLayer","createLeafletElement","componentDidMount","canAnimate","props","leaflet","options","zoomAnimation","Browser","any3d","zoomClass","mapSize","getSize","transformProp","DomUtil","testProp","tProp","_el","create","style","width","x","height","y","Heatmap","Layer","extend","onAdd","appendChild","addTo","addLayer","onRemove","leafletElement","_heatmap","reset","fitBoundsOnLoad","fitBounds","attachEvents","updateHeatmapProps","getHeatmapProps","getMax","getRadius","radius","getMaxZoom","maxZoom","getMinOpacity","minOpacity","getBlur","blur","gradient","componentWillReceiveProps","nextProps","currentProps","nextHeatmapProps","updateHeatmapGradient","hasRadiusUpdated","hasBlurUpdated","updateHeatmapRadius","updateHeatmapMax","maximum","componentWillUnmount","points","lngs","longitudeExtractor","lats","latitudeExtractor","ne","sw","latLngBounds","latLng","componentDidUpdate","invalidateSize","fitBoundsOnUpdate","shouldComponentUpdate","on","_animateZoom","e","scale","getZoomScale","zoom","offset","_getCenterOffset","center","_multiplyBy","subtract","_getMapPanePos","setTransform","TRANSFORM","getTranslateString","topLeft","containerPointToLayerPoint","setPosition","size","_width","_height","_frame","_animating","Util","requestAnimFrame","redraw","r","_r","maxIntensity","undefined","v","Math","pow","getZoom","cellSize","panePos","offsetX","offsetY","getLat","getLng","getIntensity","intensityExtractor","inBounds","p","bounds","filterUndefined","row","c","roundResults","results","result","cell","round","concat","accumulateInGrid","grid","point","latLngToContainerPoint","floor","alt","k","getBounds","Bounds","add","getDataForHeatmap","data","clear","draw","onStatsUpdate","stats","Infinity","render","propTypes","array","isRequired","func","bool","number","object"],"mappings":"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","sourcesContent":["import React from 'react';\nimport map from 'lodash.map';\nimport reduce from 'lodash.reduce';\nimport filter from 'lodash.filter';\nimport min from 'lodash.min';\nimport max from 'lodash.max';\nimport isNumber from 'lodash.isnumber';\nimport L from 'leaflet';\nimport { MapLayer, withLeaflet } from 'react-leaflet';\nimport simpleheat from 'simpleheat';\nimport PropTypes from 'prop-types';\n\nexport type LngLat = {\n  lng: number;\n  lat: number;\n}\n\nexport type Point = {\n  x: number;\n  y: number;\n}\n\nexport type Bounds = {\n  contains: (latLng: LngLat) => boolean;\n}\n\nexport type Pane = {\n  appendChild: (element: Object) => void;\n  removeChild: (element: Object) => void;\n  contains: (element: Object) => boolean;\n}\n\nexport type Panes = {\n  overlayPane: Pane;\n}\n\nexport type Map = {\n  layerPointToLatLng: (lngLat: Point) => LngLat;\n  latLngToLayerPoint: (lngLat: LngLat) => Point;\n  on: (event: string, handler: () => void) => void;\n  getBounds: () => Bounds;\n  getPanes: () => Panes;\n  invalidateSize: () => void;\n  options: Object;\n}\n\nexport type LeafletZoomEvent = {\n  zoom: number;\n  center: Object;\n}\n\nfunction isInvalid(num: number): boolean {\n  return !isNumber(num) && !num;\n}\n\nfunction isValid(num: number): boolean {\n  return !isInvalid(num);\n}\n\nfunction isValidLatLngArray(arr: Array<number>): boolean {\n  return filter(arr, isValid).length === arr.length;\n}\n\nfunction isInvalidLatLngArray(arr: Array<number>): boolean {\n  return !isValidLatLngArray(arr);\n}\n\nfunction safeRemoveLayer(leafletMap: Map, el): void {\n  const { overlayPane } = leafletMap.getPanes();\n  if (overlayPane && overlayPane.contains(el)) {\n    overlayPane.removeChild(el);\n  }\n}\n\nfunction shouldIgnoreLocation(loc: LngLat): boolean {\n  return isInvalid(loc.lng) || isInvalid(loc.lat);\n}\n\nexport default class HeatmapLayer extends MapLayer {\n  static propTypes = {\n    points: PropTypes.array.isRequired,\n    longitudeExtractor: PropTypes.func.isRequired,\n    latitudeExtractor: PropTypes.func.isRequired,\n    intensityExtractor: PropTypes.func.isRequired,\n    fitBoundsOnLoad: PropTypes.bool,\n    fitBoundsOnUpdate: PropTypes.bool,\n    onStatsUpdate: PropTypes.func,\n    /* props controlling heatmap generation */\n    max: PropTypes.number,\n    radius: PropTypes.number,\n    maxZoom: PropTypes.number,\n    minOpacity: PropTypes.number,\n    blur: PropTypes.number,\n    gradient: PropTypes.object\n  };\n\n  createLeafletElement() {\n    return null;\n  }\n\n  componentDidMount(): void {\n    const canAnimate = this.props.leaflet.map.options.zoomAnimation && L.Browser.any3d;\n    const zoomClass = `leaflet-zoom-${canAnimate ? 'animated' : 'hide'}`;\n    const mapSize = this.props.leaflet.map.getSize();\n    const transformProp = L.DomUtil.testProp(\n      ['transformOrigin', 'WebkitTransformOrigin', 'msTransformOrigin']\n    );\n    const tProp : string = (typeof transformProp == \"string\") ? transformProp : '';\n\n    var _el = L.DomUtil.create('canvas', zoomClass);\n    _el.style[tProp] = '50% 50%';\n    _el.style.width = mapSize.x + 'px';\n    _el.style.height = mapSize.y + 'px';\n\n    const el = this._el;\n\n    const Heatmap = L.Layer.extend({\n      onAdd: (leafletMap) => leafletMap.getPanes().overlayPane.appendChild(el),\n      addTo: (leafletMap) => {\n        leafletMap.addLayer(this);\n        return this;\n      },\n      onRemove: (leafletMap) => safeRemoveLayer(leafletMap, el)\n    });\n\n    this.leafletElement = new Heatmap();\n    super.componentDidMount();\n    this._heatmap = simpleheat(this._el);\n    this.reset();\n\n    if (this.props.fitBoundsOnLoad) {\n      this.fitBounds();\n    }\n    this.attachEvents();\n    this.updateHeatmapProps(this.getHeatmapProps(this.props));\n  }\n\n  getMax(props) {\n    return props.max || 3.0;\n  }\n\n  getRadius(props) {\n    return props.radius || 30;\n  }\n\n  getMaxZoom(props) {\n    return props.maxZoom || 18;\n  }\n\n  getMinOpacity(props) {\n    return props.minOpacity || 0.01;\n  }\n\n  getBlur(props) {\n    return props.blur || 15;\n  }\n\n  getHeatmapProps(props) {\n    return {\n      minOpacity: this.getMinOpacity(props),\n      maxZoom: this.getMaxZoom(props),\n      radius: this.getRadius(props),\n      blur: this.getBlur(props),\n      max: this.getMax(props),\n      gradient: props.gradient\n    };\n  }\n\n  componentWillReceiveProps(nextProps: Object): void {\n    const currentProps = this.props;\n    const nextHeatmapProps = this.getHeatmapProps(nextProps);\n\n    this.updateHeatmapGradient(nextHeatmapProps.gradient);\n\n    const hasRadiusUpdated = nextHeatmapProps.radius !== currentProps.radius;\n    const hasBlurUpdated = nextHeatmapProps.blur !== currentProps.blur;\n\n    if (hasRadiusUpdated || hasBlurUpdated) {\n      this.updateHeatmapRadius(nextHeatmapProps.radius, nextHeatmapProps.blur);\n    }\n\n    if (nextHeatmapProps.max !== currentProps.max) {\n      this.updateHeatmapMax(nextHeatmapProps.max);\n    }\n\n  }\n\n  /**\n   * Update various heatmap properties like radius, gradient, and max\n   */\n  updateHeatmapProps(props: Object) {\n    this.updateHeatmapRadius(props.radius, props.blur);\n    this.updateHeatmapGradient(props.gradient);\n    this.updateHeatmapMax(props.max);\n  }\n\n  /**\n   * Update the heatmap's radius and blur (blur is optional)\n   */\n  updateHeatmapRadius(radius: number, blur?: number): void {\n    if (radius) {\n      this._heatmap.radius(radius, blur);\n    }\n  }\n\n  /**\n   * Update the heatmap's gradient\n   */\n  updateHeatmapGradient(gradient: Object): void {\n    if (gradient) {\n      this._heatmap.gradient(gradient);\n    }\n  }\n\n  /**\n   * Update the heatmap's maximum\n   */\n  updateHeatmapMax(maximum: number): void {\n    if (maximum) {\n      this._heatmap.max(maximum);\n    }\n  }\n\n  componentWillUnmount(): void {\n    safeRemoveLayer(this.props.leaflet.map, this._el);\n  }\n\n  fitBounds(): void {\n    const points = this.props.points;\n    const lngs = map(points, this.props.longitudeExtractor);\n    const lats = map(points, this.props.latitudeExtractor);\n    const ne = { lng: max(lngs), lat: max(lats) };\n    const sw = { lng: min(lngs), lat: min(lats) };\n\n    if (shouldIgnoreLocation(ne) || shouldIgnoreLocation(sw)) {\n      return;\n    }\n\n    this.props.leaflet.map.fitBounds(L.latLngBounds(L.latLng(sw), L.latLng(ne)));\n  }\n\n  componentDidUpdate(): void {\n    this.props.leaflet.map.invalidateSize();\n    if (this.props.fitBoundsOnUpdate) {\n      this.fitBounds();\n    }\n    this.reset();\n  }\n\n  shouldComponentUpdate(): boolean {\n    return true;\n  }\n\n  attachEvents(): void {\n    const leafletMap: Map = this.props.leaflet.map;\n    leafletMap.on('viewreset', () => this.reset());\n    leafletMap.on('moveend', () => this.reset());\n    if (leafletMap.options.zoomAnimation && L.Browser.any3d) {\n      leafletMap.on('zoomanim', this._animateZoom, this);\n    }\n  }\n\n\n  _animateZoom(e: LeafletZoomEvent): void {\n    const scale = this.props.leaflet.map.getZoomScale(e.zoom);\n    const offset = this.props.leaflet.map\n                      ._getCenterOffset(e.center)\n                      ._multiplyBy(-scale)\n                      .subtract(this.props.leaflet.map._getMapPanePos());\n\n    if (L.DomUtil.setTransform) {\n      L.DomUtil.setTransform(this._el, offset, scale);\n    } else {\n      this._el.style[L.DomUtil.TRANSFORM] =\n          `${L.DomUtil.getTranslateString(offset)} scale(${scale})`;\n    }\n  }\n\n  reset(): void {\n    const topLeft = this.props.leaflet.map.containerPointToLayerPoint([0, 0]);\n    L.DomUtil.setPosition(this._el, topLeft);\n\n    const size = this.props.leaflet.map.getSize();\n\n    if (this._heatmap._width !== size.x) {\n      this._el.width = this._heatmap._width = size.x;\n    }\n    if (this._heatmap._height !== size.y) {\n      this._el.height = this._heatmap._height = size.y;\n    }\n\n    if (this._heatmap && !this._frame && !this.props.leaflet.map._animating) {\n      this._frame = L.Util.requestAnimFrame(this.redraw, this);\n    }\n\n    this.redraw();\n  }\n\n  redraw(): void {\n    const r = this._heatmap._r;\n    const size = this.props.leaflet.map.getSize();\n\n    const maxIntensity = this.props.max === undefined\n                            ? 1\n                            : this.getMax(this.props);\n\n    const maxZoom = this.props.maxZoom === undefined\n                        ? this.props.leaflet.map.getMaxZoom()\n                        : this.getMaxZoom(this.props);\n\n    const v = 1 / Math.pow(\n      2,\n      Math.max(0, Math.min(maxZoom - this.props.leaflet.map.getZoom(), 12)) / 2\n    );\n\n    const cellSize = r / 2;\n    const panePos = this.props.leaflet.map._getMapPanePos();\n    const offsetX = panePos.x % cellSize;\n    const offsetY = panePos.y % cellSize;\n    const getLat = this.props.latitudeExtractor;\n    const getLng = this.props.longitudeExtractor;\n    const getIntensity = this.props.intensityExtractor;\n\n    const inBounds = (p, bounds) => bounds.contains(p);\n\n    const filterUndefined = (row) => filter(row, c => c !== undefined);\n\n    const roundResults = (results) => reduce(results, (result, row) =>\n      map(filterUndefined(row), (cell) => [\n        Math.round(cell[0]),\n        Math.round(cell[1]),\n        Math.min(cell[2], maxIntensity),\n        cell[3]\n      ]).concat(result),\n      []\n    );\n\n    const accumulateInGrid = (points, leafletMap, bounds) => reduce(points, (grid, point) => {\n      const latLng = [getLat(point), getLng(point)];\n      if (isInvalidLatLngArray(latLng)) { //skip invalid points\n        return grid;\n      }\n\n      const p = leafletMap.latLngToContainerPoint(latLng);\n\n      if (!inBounds(p, bounds)) {\n        return grid;\n      }\n\n      const x = Math.floor((p.x - offsetX) / cellSize) + 2;\n      const y = Math.floor((p.y - offsetY) / cellSize) + 2;\n\n      grid[y] = grid[y] || [];\n      const cell = grid[y][x];\n\n      const alt = getIntensity(point);\n      const k = alt * v;\n\n      if (!cell) {\n        grid[y][x] = [p.x, p.y, k, 1];\n      } else {\n        cell[0] = (cell[0] * cell[2] + p.x * k) / (cell[2] + k); // x\n        cell[1] = (cell[1] * cell[2] + p.y * k) / (cell[2] + k); // y\n        cell[2] += k; // accumulated intensity value\n        cell[3] += 1;\n      }\n\n      return grid;\n    }, []);\n\n    const getBounds = () => new L.Bounds(L.point([-r, -r]), size.add([r, r]));\n\n    const getDataForHeatmap = (points, leafletMap) => roundResults(\n        accumulateInGrid(\n          points,\n          leafletMap,\n          getBounds(leafletMap)\n        )\n      );\n\n    const data = getDataForHeatmap(this.props.points, this.props.leaflet.map);\n\n    this._heatmap.clear();\n    this._heatmap.data(data).draw(this.getMinOpacity(this.props));\n\n    this._frame = null;\n\n    if (this.props.onStatsUpdate && this.props.points && this.props.points.length > 0) {\n      this.props.onStatsUpdate(\n        reduce(data, (stats, point) => {\n          stats.max = point[3] > stats.max ? point[3] : stats.max;\n          stats.min = point[3] < stats.min ? point[3] : stats.min;\n          return stats;\n        }, { min: Infinity, max: -Infinity })\n      );\n    }\n  }\n\n\n  render(): React.Element {\n    return null;\n  }\n\n};"]},"metadata":{},"sourceType":"module"}